STARCODE='starcode'

#' extract single nucleotide variants from piled up reads generated by call_mutations.py
#'
#' @param BC.data.file output of call_mutations.py
#' @param ALT alternative allele (A, C, G, T)
#' @param REF reference allele (A, C, G, T)
#' @param downsample maximum number of reads to process
#' @param FILTER minimum number of reads per cell barcode
#' @returns dataframe with cell barcodes and mutation
#
extract_mutation = function(BC.data.file, ALT, REF, downsample = NA, FILTER = 4) {
  BC.data = data.table::fread(BC.data.file)

  if(!is.na(downsample)) {
    BC.data = BC.data[sample(seq(1,nrow(BC.data)), size = downsample),]
  }

  BC.list = BC.data %>% group_by(bc, umi) %>% summarize(n = n()) %>% filter (n > FILTER)

  # run starcode and identify UMI clusters
  UMIs.collapsed = data.frame()
  for (bc in unique(BC.list$bc)) {
    message(bc)
    filehandle.in = tempfile()
    filehandle.out = tempfile()
    write.table(x=BC.list[which(BC.list$bc == bc), c('umi', 'n')], file = filehandle.in, sep = '\t', row.names = F, quote = F, col.names = F)

    system(paste0(STARCODE, ' -d 3 -i ', filehandle.in, ' -o ', filehandle.out, ' --print-clusters'))
    starcode.output = as.data.frame(read.csv2(filehandle.out, sep = '\t', header = F))
    colnames(starcode.output) = c('umi', 'n', 'umi.non.collapsed')
    starcode.output$bc = bc

    UMIs.collapsed = rbind(UMIs.collapsed, starcode.output)

    unlink(filehandle.in)
    unlink(filehandle.out)
  }

  # for each UMI calculate consensus base
  UMIs.collapsed$consensus = apply(UMIs.collapsed, 1, FUN = function(x) {
    umis = unlist(strsplit(x['umi.non.collapsed'], split = ',')[[1]])
    consensus = names(sort(table(BC.data$base[which(BC.data$bc == x['bc'] & BC.data$umi %in% umis)]), decreasing = T))
    consensus[1]
  })

  # for each BC count ref and alt bases
  results = UMIs.collapsed %>% group_by(bc) %>% summarize(alt = length(which(consensus == ALT)),
                                                          ref = length(which(consensus == REF)))
  results$mutated = ifelse(results$alt / (results$alt + results$ref) > 0.2, 'mutated', 'wildtype')
  results$vaf = results$alt / (results$alt + results$ref)
  results
}


#' extract indels or insertions from piled up reads generated by call_mutations.py
#'
#' @param BC.data.file output of call_mutations.py
#' @param REF reference allele (A, C, G, T)
#' @param downsample maximum number of reads to process
#' @param CONSENSUS number of nucleotides deleted or inserted
#' @param FILTER minimum number of reads per cell barcode
#' @returns dataframe with cell barcodes and insertion/deletion
#
extract_indel = function(BC.data.file, REF, downsample = NA, CONSENSUS = -1, FILTER = 4) {
  BC.data = data.table::fread(BC.data.file)

  if(!is.na(downsample)) {
    BC.data = BC.data[sample(seq(1,nrow(BC.data)), size = downsample),]
  }

  BC.list = BC.data %>% group_by(bc, umi) %>% summarize(n = n()) %>% filter (n > FILTER)

  # run starcode and identify UMI clusters
  UMIs.collapsed = data.frame()
  for (bc in unique(BC.list$bc)) {
    message(bc)
    filehandle.in = tempfile()
    filehandle.out = tempfile()
    write.table(x=BC.list[which(BC.list$bc == bc), c('umi', 'n')], file = filehandle.in, sep = '\t', row.names = F, quote = F, col.names = F)

    system(paste0(STARCODE, ' -d 3 -i ', filehandle.in, ' -o ', filehandle.out, ' --print-clusters'))
    starcode.output = as.data.frame(read.csv2(filehandle.out, sep = '\t', header = F))
    colnames(starcode.output) = c('umi', 'n', 'umi.non.collapsed')
    starcode.output$bc = bc

    UMIs.collapsed = rbind(UMIs.collapsed, starcode.output)

    unlink(filehandle.in)
    unlink(filehandle.out)
  }

  # for each UMI calculate consensus indel
  UMIs.collapsed$consensus = apply(UMIs.collapsed, 1, FUN = function(x) {
    umis = unlist(strsplit(x['umi.non.collapsed'], split = ',')[[1]])
    consensus = names(sort(table(BC.data$indel[which(BC.data$base == REF & BC.data$bc == x['bc'] & BC.data$umi %in% umis)]), decreasing = T))
    consensus[1]
  })

  # for each BC count ref and alt bases
  results = UMIs.collapsed %>% group_by(bc) %>% summarize(alt = length(which(consensus == CONSENSUS)),
                                                          ref = length(which(consensus == 0)))
  results$mutated = ifelse(results$alt / (results$alt + results$ref) > 0.2, 'mutated', 'wildtype')
  results$vaf = results$alt / (results$alt + results$ref)
  results
}


#' detect truncated transcripts
#'
#' @param BC.data.file output of fusion_gene.py
#' @param POS position where truncation occurs
#' @param downsample maximum number of reads to process
#' @param CONSENSUS number of nucleotides deleted or inserted
#' @param FILTER minimum number of reads per cell barcode
#' @returns dataframe with cell barcodes and information on full length (wildtype) or truncated transcript (mutated)
#
extract_length_diff = function(BC.data.file, POS, downsample = NA, FILTER = 4) {
  BC.data = data.table::fread(BC.data.file)

  if(!is.na(downsample)) {
    BC.data = BC.data[sample(seq(1,nrow(BC.data)), size = downsample),]
  }

  BC.list = BC.data %>% group_by(bc, umi) %>% summarize(n = n()) %>% filter (n > FILTER)

  # run starcode and identify UMI clusters
  UMIs.collapsed = data.frame()
  for (bc in unique(BC.list$bc)) {
    message(bc)
    filehandle.in = tempfile()
    filehandle.out = tempfile()
    write.table(x=BC.list[which(BC.list$bc == bc), c('umi', 'n')], file = filehandle.in, sep = '\t', row.names = F, quote = F, col.names = F)

    system(paste0(STARCODE, ' -d 3 -i ', filehandle.in, ' -o ', filehandle.out, ' --print-clusters'))
    starcode.output = as.data.frame(read.csv2(filehandle.out, sep = '\t', header = F))
    colnames(starcode.output) = c('umi', 'n', 'umi.non.collapsed')
    starcode.output$bc = bc

    UMIs.collapsed = rbind(UMIs.collapsed, starcode.output)

    unlink(filehandle.in)
    unlink(filehandle.out)
  }

  # for each UMI calculate consensus ref_end
  UMIs.collapsed$consensus = apply(UMIs.collapsed, 1, FUN = function(x) {
    umis = unlist(strsplit(x['umi.non.collapsed'], split = ',')[[1]])
    consensus = names(sort(table(BC.data$ref_end[which(BC.data$bc == x['bc'] & BC.data$umi %in% umis)]), decreasing = T))
    consensus[1]
  })

  # for each BC count ref and alt bases
  results = UMIs.collapsed %>% group_by(bc) %>% summarize(alt = length(which(consensus == POS)),
                                                          ref = length(which(consensus > POS)))
  results$mutated = ifelse(results$alt / (results$alt + results$ref) > 0.2, 'mutated', 'wildtype')
  results$vaf = results$alt / (results$alt + results$ref)
  results
}


#' extract fusion genes or CAR sequences
#'
#' @param BC.data.file output of fusion_gene.py
#' @param WILDTYPE wildtype gene
#' @param FUSION fusion partner
#' @param downsample maximum number of reads to process
#' @param FILTER minimum number of reads per cell barcode
#' @returns dataframe with cell barcodes and information on wildtype or fusion (mutated)
#
extract_fusion_gene = function(BC.data.file, WILDTYPE, FUSION, downsample=NA, filter = 4) {
  BC.data = data.table::fread(BC.data.file)
  if(!is.na(downsample)) {
    BC.data = BC.data[sample(seq(1,nrow(BC.data)), size = downsample),]
  }

  BC.list = BC.data %>% group_by(bc, umi, gene) %>% summarize(n = n()) %>% filter (n > filter)

  # run starcode and identify UMI clusters
  UMIs.collapsed = data.frame()
  for (bc in unique(BC.list$bc)) {
    message(bc)
    filehandle.in = tempfile()
    filehandle.out = tempfile()
    write.table(x=BC.list[which(BC.list$bc == bc), c('umi', 'n')], file = filehandle.in, sep = '\t', row.names = F, quote = F, col.names = F)

    system(paste0(STARCODE, ' -d 3 -i ', filehandle.in, ' -o ', filehandle.out, ' --print-clusters'))
    starcode.output = as.data.frame(read.csv2(filehandle.out, sep = '\t', header = F))
    colnames(starcode.output) = c('umi', 'n', 'umi.non.collapsed')
    starcode.output$bc = bc

    UMIs.collapsed = rbind(UMIs.collapsed, starcode.output)

    unlink(filehandle.in)
    unlink(filehandle.out)
  }

  BC.data.condensed = BC.data %>% group_by(gene, bc, umi) %>% tally()
  BC.data.condensed$bc.umi = paste0(BC.data.condensed$bc, '.', BC.data.condensed$umi)
  UMIs.collapsed$bc.umi = paste0(UMIs.collapsed$bc, '.', UMIs.collapsed$umi)
  rownames(UMIs.collapsed) = UMIs.collapsed$bc.umi

  BC.data.condensed = BC.data.condensed[which(BC.data.condensed$bc.umi %in% UMIs.collapsed$bc.umi),]
  BC.data.condensed$count = UMIs.collapsed[BC.data.condensed$bc.umi, 'n']

  results = BC.data.condensed %>% group_by(gene, bc) %>% tally() %>% group_by(bc) %>% tidyr::pivot_wider(names_from = 'gene', values_from = 'n')
  results[is.na(results)] = 0
  results$vaf = results[,FUSION] / (results[,FUSION] + results[,WILDTYPE])
  results$mutated = ifelse(results$vaf > 0, 'mutated', 'wildtype')
  results = as.data.frame(results)
  colnames(results)[4:5] = c('vaf', 'mutated')

  results$vaf = as.numeric(results$vaf[,1])
  results$mutated = as.character(results$mutated[,1])

  results
}


#' extract reads covering exon
#'
#' @param BC.data.file output of fusion_gene.py
#' @param GENE gene
#' @param EXON exon
#' @param downsample maximum number of reads to process
#' @param FILTER minimum number of reads per cell barcode
#' @returns dataframe with cell barcodes and information on exon expression
#
extract_isoforms = function(BC.data.file, GENE, EXON, downsample=NA, filter = 4) {
  BC.data = data.table::fread(BC.data.file) %>% filter(gene == GENE & exon == EXON)
  if(!is.na(downsample)) {
    BC.data = BC.data[sample(seq(1,nrow(BC.data)), size = downsample),]
  }

  BC.list = BC.data %>% group_by(bc, umi) %>% summarize(n = n()) %>% filter (n > filter)

  # run starcode and identify UMI clusters
  UMIs.collapsed = data.frame()
  for (bc in unique(BC.list$bc)) {
    filehandle.in = tempfile()
    filehandle.out = tempfile()
    write.table(x=BC.list[which(BC.list$bc == bc), c('umi', 'n')], file = filehandle.in, sep = '\t', row.names = F, quote = F, col.names = F)

    system(paste0(STARCODE, ' -d 3 -i ', filehandle.in, ' -o ', filehandle.out, ' --print-clusters'))
    starcode.output = as.data.frame(read.csv2(filehandle.out, sep = '\t', header = F))
    colnames(starcode.output) = c('umi', 'n', 'umi.non.collapsed')
    starcode.output$bc = bc

    UMIs.collapsed = rbind(UMIs.collapsed, starcode.output)

    unlink(filehandle.in)
    unlink(filehandle.out)
  }

  BC.data.condensed = BC.data %>% group_by(bc, umi) %>% summarize(overlap = mean(overlap), length = mean(length))
  BC.data.condensed$bc.umi = paste0(BC.data.condensed$bc, '.', BC.data.condensed$umi)
  UMIs.collapsed$bc.umi = paste0(UMIs.collapsed$bc, '.', UMIs.collapsed$umi)
  rownames(UMIs.collapsed) = UMIs.collapsed$bc.umi

  BC.data.condensed = BC.data.condensed[which(BC.data.condensed$bc.umi %in% UMIs.collapsed$bc.umi),]
  BC.data.condensed$count = UMIs.collapsed[BC.data.condensed$bc.umi, 'n']
  BC.data.condensed$detected = ifelse(BC.data.condensed$overlap > 0.8*BC.data.condensed$length, 'detected', 'not.detected')

  results = BC.data.condensed %>% group_by(bc, detected) %>% tally() %>% group_by(bc) %>% tidyr::pivot_wider(names_from = 'detected', values_from = 'n')
  results[is.na(results)] = 0
  results = as.data.frame(results)

  results
}

#' plot knee plot
#' @param x pileup data
#' @param cutoff draw cut off at indicated number of reads
#' @param downsample downsample to indicated number of reads
knee_plot = function(x, cutoff = NA, downsample = NA) {
  if (!is.na(downsample)) {
    x = x[sample(nrow(x), downsample),]
  }

  boo = x %>% group_by(bc) %>% summarize(umis = length(umi))

  boo = boo[order(boo$umis, decreasing = T),]
  boo$rank = seq(1, nrow(boo))
  p = ggplot(boo, aes(x=rank, y=umis)) + geom_line() +
    scale_x_log10('Rank', limits = c(1,50000)) +
    scale_y_log10('Reads', limits = c(1,50000)) +
    theme_classic() +
    theme(axis.title = element_text('Arial', size=8, color='black'),
          axis.text = element_text('Arial', size=8, color='black'),
          axis.ticks = element_line(color='black'))

  if (!is.na(cutoff)) {
    p = p + geom_hline(yintercept = cutoff, color='red')
  }

  p
}
